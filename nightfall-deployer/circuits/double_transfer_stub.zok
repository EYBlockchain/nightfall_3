
struct OldCommitmentPreimage {
	u32[8] id
	u32[8] value
	u32[8] salt
	u32[8] hash
	field rootKey
}

struct NewCommitmentPreimage {
	field[2] zkpPublicKeyRecipient
	u32[8] value
	u32[8] salt
}

struct CompressedPoint {
	bool parity
	field ordinate
}

def main(\
	private field[2] fErcAddress,\
	private OldCommitmentPreimage[2] oldCommitment,\
	private NewCommitmentPreimage[2] newCommitment,\
	field[2] fNewCommitmentHash,\
	field[2] fNullifier,\
	field[2] root,\
	private field[2][32] path,\
	private field[2] order,\
	private u32[8] ephemeralKey,\
	CompressedPoint compressedEphemeralPublicKey,\
	field[4] cipherText\
)->():

	field u = 0
	u32 v = 0x00000000
	bool b = true
	for u32 j in 0..2 do
		u = u + fErcAddress[j] + fNewCommitmentHash[j] + fNullifier[j] - root[j]
		for u32 i in 0..8 do
			v = v + oldCommitment[j].id[i] +\
				oldCommitment[j].value[i] +\
				oldCommitment[j].salt[i] +\
				oldCommitment[j].hash[i] +\
				newCommitment[j].value[i] +\
				newCommitment[j].salt[i]
		endfor
	endfor

	u32 w = 0x00000000

	for u32 j in 0..2 do
		for u32 i in 0..32 do
			u = u * path[j][i]
		endfor
	endfor

	for u32 j in 0..2 do
		for u32 i in 0..2 do
			u = u * newCommitment[j].zkpPublicKeyRecipient[i]
		endfor
	endfor

	u = u * order[0] * order[1] * oldCommitment[0].rootKey * oldCommitment[1].rootKey
	assert(v == v)
	assert(u == u)
	assert(w == w)
	assert(b == b)
	assert(ephemeralKey == ephemeralKey)
	assert(cipherText == cipherText)

	return
