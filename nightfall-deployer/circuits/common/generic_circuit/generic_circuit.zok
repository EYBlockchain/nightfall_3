
from "../utils/structures.zok" import Point, SHIFT, NUMBER_COMMITMENTS, NUMBER_NULLIFIERS
from "../utils/calculations.zok" import sum
from "../casts/u32_array_to_field.zok" import main as u32_array_to_field
from "./Verifiers/verify_structure.zok" import main as verify_structure
from "./Verifiers/verify_encryption.zok" import main as verify_encryption
from "./Verifiers/verify_nullifiers.zok" import main as verify_nullifiers
from "./Verifiers/verify_commitments.zok" import main as verify_commitments

def main<TxType, NumNullifiers, NumCommitments, Transfer>(\
    field value,\
	u32 transactionType,\
	field tokenType,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[NUMBER_COMMITMENTS] commitments,\
	field[NUMBER_NULLIFIERS] nullifiers,\
	field[NUMBER_NULLIFIERS] historicRootBlockNumberL2,\
	field[2] compressedSecrets,\
    field fee,\
    field commitmentsFee,\
    field[2] nullifiersFee,\
    field ercAddressFee,\
    u32[8] tokenIdFee,\
    field[NumNullifiers] nullifierRoots,\
    private field[NumNullifiers] oldCommitmentValues,\
    private field[NumNullifiers] oldCommitmentSalts,\
    private field[NumNullifiers] rootKey,\
    private field[NumNullifiers][32] paths,\
	private field[NumNullifiers] orders,\
    private field[NumCommitments] newCommitmentValues,\
    private field[NumCommitments] newCommitmentSalts,\
    private Point[NumCommitments] recipientPublicKey,\
    private field[2] oldCommitmentFeeValues,\
    private field[2] oldCommitmentFeeSalts,\
    private field[2] rootKeysFee,\
    private field[2][32] pathsFee,\
	private field[2] ordersFee,\
    private field newCommitmentFeeValue,\
    private field newCommitmentFeeSalt,\
    private Point recipientPublicKeyFee,\
    private u32[Transfer][8] ephemeralKey,\
    private field[Transfer] ercAddressTransfer,\
    private u32[Transfer][8] idTransfer\
)-> (bool):
    
    //Check that if transaction type is transfer, Transfer generic parameter is set to 1. Otherwise, check Transfer is 0
    assert((TxType == 1 && Transfer == 1) || (TxType != 1 && Transfer == 0))
    
    //Verify public transaction structure
    assert(verify_structure::<TxType, NumNullifiers, NumCommitments>(\
        value,\
	    transactionType,\
	    tokenType,\
	    tokenId,\
	    ercAddress,\
	    recipientAddress,\
	    commitments,\
	    nullifiers,\
	    historicRootBlockNumberL2,\
	    compressedSecrets,\
        fee,\
        commitmentsFee,\
        nullifiersFee,\
    ))

    //Check that values match
    field oldValues = sum(oldCommitmentValues) + if TxType == 0 then value else 0 fi
    field newValues = sum(newCommitmentValues) + if TxType == 2 then value else 0 fi
    assert(oldValues == newValues)

    //Check that values fee match
    assert(sum(oldCommitmentFeeValues) == fee + newCommitmentFeeValue)

    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = u32_array_to_field(tokenId[1..8]) 
    field packedErcAddress = ercAddress + u32_array_to_field([tokenId[0]]) * SHIFT 

    //If TxType is a transfer, Transfer generic parameter will be set to 1 and this loop will be run once
    //Otherwise, the loop will go from 0..0 so it will never enter
    for u32 i in 0..Transfer do
        //Calculate idRemainder and packedErcAddress for a transfer transaction
        idRemainder = u32_array_to_field(idTransfer[0][1..8]) 
        packedErcAddress = ercAddressTransfer[0] + u32_array_to_field([idTransfer[0][0]]) * SHIFT 
    endfor

    //Verify nullifiers
    Point firstInputZkpPublicKeys = [0,0]

    firstInputZkpPublicKeys = verify_nullifiers::<NumNullifiers, 0>(packedErcAddress, idRemainder,\
        nullifiers, nullifierRoots, oldCommitmentValues, oldCommitmentSalts, rootKey, paths, orders)

    //Verify new Commmitments
    assert(verify_commitments::<NumCommitments, TxType>(packedErcAddress, idRemainder, commitments, firstInputZkpPublicKeys,\
    newCommitmentValues, newCommitmentSalts, recipientPublicKey))
        
    //Verify Kem Dem encryption
    assert(verify_encryption::<NumCommitments,Transfer>(ercAddress,tokenId, compressedSecrets,\
        packedErcAddress,idRemainder,newCommitmentValues,newCommitmentSalts,recipientPublicKey,\
        recipientAddress, ephemeralKey))
    
    field idRemainderFee = u32_array_to_field(tokenIdFee[1..8]) 
    field packedErcAddressFee = ercAddressFee + u32_array_to_field(tokenIdFee[0]) * SHIFT

    //Verify Fee Nullifiers
    Point firstInputZkpPublicKeys = verify_nullifiers::<2, 1>(packedErcAddressFee, idRemainderFee,\
        nullifiers, nullifierRoots, oldCommitmentValues, oldCommitmentSalts, rootKey, paths, orders)

    //Verify Fee Commitments
    assert(verify_commitments::<2, TxType, 1>(packedErcAddressFee, idRemainderFee, commitments, firstInputZkpPublicKeys,\
    newCommitmentValues, newCommitmentSalts, recipientPublicKey))

    return true
