from "../../utils/structures.zok" import Point, PublicTransaction, Nullifiers, Commitments, Transfer, SHIFT;
from "../../utils/calculations.zok" import sum;
from "../../casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "../../casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "../Verifiers/verify_structure.zok" import main as verify_structure;
from "../Verifiers/verify_encryption.zok" import main as verify_encryption;
from "../Verifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "../Verifiers/verify_commitments.zok" import main as verify_commitments;

def withdraw_generic<N,C>(\
    field value,\
    field fee,\
	field transactionType,\
	field tokenType,\
	field[N] historicRootBlockNumberL2,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[C] commitments,\
	field[N] nullifiers,\
	field[2] compressedSecrets,\
    field[N] roots,\
    field maticAddress,\
    private u8[N][31] oldCommitmentsValue,\
 	private field[N] oldCommitmentsSalt,\
    private field[N] rootKey,\
    private field[N][32] paths,\
	private field[N] orders,\
    private u8[C][31] newCommitmentsValue,\
 	private field[C] newCommitmentsSalt,\
    private Point[C] recipientPublicKey\
) -> bool {
    
    //Verify public transaction structure
    assert(verify_structure::<N,C,2>(\
        value,\
        fee,\
	    transactionType,\
	    tokenType,\
        historicRootBlockNumberL2,\
	    tokenId,\
	    ercAddress,\
	    recipientAddress,\
	    commitments,\
	    nullifiers,\
	    compressedSecrets\
    ));

    field[N] nullifiersValue = u8_array_to_field(oldCommitmentsValue);
    field[C] commitmentsValue = u8_array_to_field(newCommitmentsValue);

    //Check that values match
     assert(sum(nullifiersValue) == sum(commitmentsValue) + fee + value); 
    
    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = u32_array_to_field(tokenId[1..8]);
    field packedErcAddress = ercAddress + u32_array_to_field([tokenId[0]]) * SHIFT; 

    //Verify nullifiers
    Point firstInputZkpPublicKeys = verify_nullifiers::<1,N>(packedErcAddress, idRemainder,\
        nullifiers, roots, nullifiersValue, oldCommitmentsSalt,\
        rootKey, paths, orders, maticAddress);

    //Verify new Commmitments
    assert(verify_commitments::<0,C>(packedErcAddress, idRemainder, [commitments[0], commitments[1]],\
    commitmentsValue, newCommitmentsSalt, recipientPublicKey, maticAddress));

    //Verify Changes
    assert(commitmentsValue[C - 2] == 0 || firstInputZkpPublicKeys == recipientPublicKey[C - 2]);
    
     //Verify Fee change
    assert(commitmentsValue[C - 1] == 0 || firstInputZkpPublicKeys == recipientPublicKey[C - 1]);

    return true;
}
