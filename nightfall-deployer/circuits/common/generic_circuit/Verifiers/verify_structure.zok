from "../../casts/u32_array_to_field.zok" import main as u32_array_to_field
from "utils/casts/u32_to_field.zok" import main as u32_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8

/*
* Given a Public tx, check that the structure and all the public parameters are valid
*/
def main<TxType>(\
    field value,\
<<<<<<< HEAD
=======
    field fee,\
>>>>>>> 25c9b6c5 (build: continue to implement payments)
	field transactionType,\
	field tokenType,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[2] commitments,\
	field[2] nullifiers,\
    field[1] commitmentFee,\
    field[2] nullifiersFee,\
	field[2] historicRootBlockNumberL2,\
<<<<<<< HEAD
=======
    field[2] historicRootBlockNumberL2Fee,\
>>>>>>> 25c9b6c5 (build: continue to implement payments)
	field[2] compressedSecrets\
) -> (bool):

    //Check that transaction type matches        
    assert(u32_to_field(TxType) == transactionType) 

    //ErcAddress cannot be zero. In transfer will contain the encrypted version of the ercAddress belonging to the ciphertext
    assert(ercAddress != 0)

    //Withdrawals will have a recipientAddress and also transfers, since we are using it as a way to send the public ephemeral key
    assert((TxType == 0 && recipientAddress == field_to_u32_8(0))\
        || (TxType != 0 && recipientAddress != field_to_u32_8(0)))
    
    field id = u32_array_to_field(tokenId)

    //Transfers will have value equal to zero and id different than zero because it will contain the encrypted version 
    //of the id beloning to the CipherText
    //For deposits and withdrawals, check that combination id and value matches the token type
    //ERC20 -> Value > 0 and Id == 0
    //ERC721 -> Value == 0
    //ERC1155 -> Value > 0
    assert((TxType == 1 && value == 0)\
        || (TxType != 1 &&\
            (tokenType == 0 && value != 0 && id == 0)\
        ||  (tokenType == 1 && value == 0)\
        ||  (tokenType == 2 && value != 0)))
    
    //Check commitments
    assert((TxType == 0 && commitments[0] != 0 && commitments[1] == 0) ||\
        (TxType == 1 && commitments[0] != 0 && commitments[0] != commitments[1]) ||\
        (TxType == 2 && commitments[1] == 0))
    
    //Check nullifiers
    assert(\
        (TxType == 0 && nullifiers[0] == 0 &&  nullifiers[1] == 0) || \
        ((TxType == 1 || TxType == 2) &&\
            (nullifiers[0] != 0 && nullifiers[0] != nullifiers[1])\
        )\
    )

    //For transfers, compressedSecrets needs to have at least one element different than zero
    //For deposits and withdrawals, compressedSecrets will be zero
    assert((TxType == 1 && (compressedSecrets[0] != 0 || compressedSecrets[1] != 0))\
        || (TxType != 1 && compressedSecrets[0] == 0 && compressedSecrets[1] == 0))
    
    //Check fee structure
    //Fee can be set to zero
    assert((TxType == 0 && nullifiersFee[0] == 0 && nullifiersFee[1] == 0 && commitmentFee[0] == 0)\
     || (TxType != 0 && nullifiersFee[0] != 0))

    return true
