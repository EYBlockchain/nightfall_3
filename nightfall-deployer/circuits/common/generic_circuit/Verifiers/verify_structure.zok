from "../../casts/u32_array_to_field.zok" import main as u32_array_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8

/*
* Given a Public tx, check that the structure and all the public parameters are valid
*/
def main<TxType>(\
    field value,\
	u32 transactionType,\
	field tokenType,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[2] commitments,\
	field[2] nullifiers,\
	field[2] historicRootBlockNumberL2,\
	field[2] compressedSecrets\
) -> (bool):

   //Check that transaction type matches    
    assert(TxType == transactionType)

    //ErcAddress cannot be zero. In transfer will contain the encrypted version of the ercAddress belonging to the ciphertext
    assert(ercAddress != 0)

    //Withdrawals will have a recipientAddress and also transfers, since we are using it as a way to send the public ephemeral key
    assert((TxType == 0 && recipientAddress == field_to_u32_8(0))\
        || (TxType != 0 && recipientAddress != field_to_u32_8(0)))
    
    field id = u32_array_to_field(tokenId)

    //Transfers will have value equal to zero and id different than zero because it will contain the encrypted version 
    //of the id beloning to the CipherText
    //For deposits and withdrawals, check that combination id and value matches the token type
    //ERC20 -> Value > 0 and Id == 0
    //ERC721 -> Value == 0
    //ERC1155 -> Value > 0
    assert((TxType == 1 && value == 0)\
        || (TxType != 1 &&\
            (tokenType == 0 && value != 0 && id == 0)\
        ||  (tokenType == 1 && value == 0)\
        ||  (tokenType == 2 && value != 0)))
    
    
    //Check commitments
    assert((TxType == 0 && commitments[0] != 0 && commitments[1] == 0) ||\
        (TxType == 1 && commitments[0] != 0 && commitments[0] != commitments[1]) ||\
        (TxType == 2 && commitments[1] == 0))

    //Check nullifiers
    assert(TxType == 0 || ((TxType == 1 || TxType == 2) &&\
     (nullifiers[0] != 0 && nullifiers[0] != nullifiers[1] && historicRootBlockNumberL2[0] != 0)))
    
    //For transfers, compressedSecrets needs to have at least one element different than zero
    //For deposits and withdrawals, compressedSecrets will be zero
    assert((TxType == 1 && (compressedSecrets[0] != 0 || compressedSecrets[1] != 0))\
        || (TxType != 1 && compressedSecrets[0] == 0 && compressedSecrets[1] == 0))

    return true