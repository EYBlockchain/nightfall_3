from "ecc/babyjubjubParams" import BabyJubJubParams;
from "ecc/babyjubjubParams" import main as curveParams;
from "ecc/edwardsScalarMult" import main as scalarMult;
from "utils/casts/u32_to_field" import main as u32_to_field;
from "hashes/poseidon/poseidon.zok" import main as poseidon;

struct EncryptedMsgs<N> {
    field[N] cipherText;
    field[2] ephemeralPublicKey;
}

// DOMAIN_KEM = field(SHA256('nightfall-kem'))
const field DOMAIN_KEM = 21033365405711675223813179268586447041622169155539365736392974498519442361181;
// DOMAIN_KEM = field(SHA256('nightfall-dem'))
const field DOMAIN_DEM = 1241463701002173366467794894814691939898321302682516549591039420117995599097;

def kem(bool[256] ephemeralKey, field[2] ephemeralPub) -> field {
    BabyJubJubParams context = curveParams();
	field[2] g = [context.Gu, context.Gv];
    field[2] sharedSecret = scalarMult(ephemeralKey, ephemeralPub, context);
    field encryptionKey = poseidon([sharedSecret[0], sharedSecret[1], DOMAIN_KEM]);
    return encryptionKey;
}

def dem<N>(field encryptionKey, field[N] plainText) -> field[N]{
    field[N] mut output = [0; N];
    for u32 i in 0..N {
        output[i] = poseidon([encryptionKey, DOMAIN_DEM, u32_to_field(i)]) + plainText[i];
    }
    return output;
}

def main<N>(bool[256] ephemeralKey,field[2] recipientPub,field[N] plainText) -> EncryptedMsgs<N> {
    BabyJubJubParams context = curveParams();
	field[2] g = [context.Gu, context.Gv];
    field[2] ephemeralPub = scalarMult(ephemeralKey, g, context);

    field encryptionKey = kem(ephemeralKey, recipientPub);

    field[N] cipherText = dem(encryptionKey, plainText);
    EncryptedMsgs<N> e = EncryptedMsgs { cipherText: cipherText, ephemeralPublicKey: ephemeralPub};
    return e;
}
