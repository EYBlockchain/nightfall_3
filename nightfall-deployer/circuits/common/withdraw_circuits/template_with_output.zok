from "ecc/babyjubjubParams" import BabyJubJubParams, main as curveParams
from "ecc/edwardsCompress" import main as edwardsCompress

from "hashes/poseidon/poseidon.zok" import main as poseidon
from "../utils/structures.zok" import CommitmentPreimage, Point, PRIVATE_KEY_DOMAIN, NULLIFIER_KEY_DOMAIN, SHIFT
from "../utils/calculations.zok" import sum, calculateCommitmentHashesN, calculateNullifiersN
from "../merkle-tree/path-check.zok" import main as pathCheck
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8
from "ecc/edwardsScalarMult" import main as scalarMult
from "utils/pack/u32/pack256.zok" import main as u32_8_to_field
from "../casts/u8_array_to_field.zok" import main as u8_array_to_field
from "../casts/u32_array_to_field.zok" import main as u32_array_to_field

def main<CInps,COuts>(\
    field [CInps] nullifiers,\
    field ercAddress,\
    u32[8] tokenId,\
    field[CInps] root,\
    field withdrawnValue,\
    private field[CInps] oldCommitmentValues,\
    private field[CInps] oldCommitmentSalts,\
    private field[CInps] rootKey,\
    private field[CInps][32] path,\
	private field[CInps] order,\
    private field[COuts] newCommitmentValues,\
    private field[COuts] newCommitmentSalts,\
    private Point[COuts] recipientPublicKey,\
    field[COuts] newCommitmentHash\
)-> bool:
    // Get Curve Params
    BabyJubJubParams context = curveParams()
    Point g = [context.Gu, context.Gv]


    field[CInps] nullifierKeys = [0; CInps]
    Point[CInps] zkpPublicKeys = [[0,0]; CInps]
    for u32 i in 0..CInps do
      // Calculation of zkpPrivateKey and nullifierKey from rootKey
      field zkpPrivateKey = poseidon([rootKey[i], PRIVATE_KEY_DOMAIN])

      nullifierKeys[i] = poseidon([rootKey[i], NULLIFIER_KEY_DOMAIN])

      // Calculate zkpPublicKey
      zkpPublicKeys[i] = scalarMult(field_to_bool_256(zkpPrivateKey), g, context)

      assert(sum(oldCommitmentValues) == withdrawnValue + sum(newCommitmentValues))
    endfor

    //Check the change address is mine (TODO CHECK WHETHER THIS IS COMPRESSED)
    assert(recipientPublicKey[COuts - 1] == zkpPublicKeys[0])
    /*
    Calculate + Check Commitment/Nullifiers
    */

    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
	field idTop4Bytes = u32_array_to_field([tokenId[0]])
	field idRemainder = u32_array_to_field(tokenId[1..8])
	field packedErcAddress = ercAddress + idTop4Bytes * SHIFT

    // Check old commitments hash
    field[CInps] calculatedInputCommitmentHash = calculateCommitmentHashesN(\
        packedErcAddress,\
		idRemainder,\
		oldCommitmentValues,\
		zkpPublicKeys,\
		oldCommitmentSalts\
    )

    // Use calculated old commiment hashes in nullifier calculation
    field[CInps] outputNullifier = calculateNullifiersN(nullifierKeys, calculatedInputCommitmentHash)
    assert(outputNullifier == nullifiers)
   
    
    field[COuts] outputCommitments = calculateCommitmentHashesN(\
        packedErcAddress,\
		idRemainder,\
        newCommitmentValues,\
        recipientPublicKey,\
        newCommitmentSalts\
    )
    assert(outputCommitments == newCommitmentHash)

    for u32 i in 0..CInps do
      assert(pathCheck([root[i], ...path[i]], order[i], calculatedInputCommitmentHash[i]))
   endfor
   return true
