
from "../utils/structures.zok" import Point, PublicTransaction, Nullifiers, Commitments, Transfer, SHIFT;
from "../utils/calculations.zok" import sum;
from "../utils/calculateKeys.zok" import Keys, main as calculateKeys;
from "../casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "../casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "../verifiers/verify_duplicates.zok" import main as verify_duplicates;
from "../verifiers/verify_encryption.zok" import main as verify_encryption;
from "../verifiers/nullifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "../verifiers/nullifiers/verify_nullifiers_generic.zok" import main as verify_nullifiers_generic;
from "../verifiers/commitments/verify_commitments.zok" import main as verify_commitments;
from "../verifiers/commitments/verify_commitments_generic.zok" import main as verify_commitments_generic;
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8;

def transfer_generic<N,C>(\
    field value,\
    field fee,\
	field transactionType,\
	field tokenType,\
	field[N] historicRootBlockNumberL2,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[C] commitments,\
	field[N] nullifiers,\
	field[2] compressedSecrets,\
    field[N] roots,\
    field feeAddress,\
    private field rootKey,\
    private u8[N][31] oldCommitmentsValue,\
 	private field[N] oldCommitmentsSalt,\
    private field[N][32] paths,\
	private field[N] orders,\
    private u8[C][31] newCommitmentsValue,\
 	private field[C] newCommitmentsSalt,\
    private Point[C] recipientPublicKey,\
    private field ercAddressTransfer,\
    private u32[8] idTransfer,\
    private u32[8] ephemeralKey\
) -> bool {
    // Verify public transaction structure
    assert(ercAddress != 0);
    assert(recipientAddress != field_to_u32_8(0));
    assert(value == 0);
    assert(compressedSecrets[0] != 0 || compressedSecrets[1] != 0);
    assert(commitments[0] != 0 && nullifiers[0] != 0);

    //Verify duplicates
    assert(verify_duplicates::<N,C>(commitments, nullifiers));

    field[N] nullifiersValue = u8_array_to_field(oldCommitmentsValue);
    field[C] commitmentsValue = u8_array_to_field(newCommitmentsValue);

    //Check that values match
    assert(sum(nullifiersValue) == sum(commitmentsValue) + fee); 
   
    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = u32_array_to_field(idTransfer[1..8]); 
    field packedErcAddress = ercAddressTransfer + u32_array_to_field([idTransfer[0]]) * SHIFT; 

    //Calculate Keys
    Keys keys = calculateKeys(rootKey);

    //Verify nullifiers
    assert(verify_nullifiers::<1>(packedErcAddress, idRemainder,\
        nullifiers[0..1], roots[0..1], nullifiersValue[0..1], oldCommitmentsSalt[0..1],\
        paths[0..1], orders[0..1], keys.nullifierKey, keys.zkpPublicKey));

    u32 genericNullifiers = N - 1;
    assert(verify_nullifiers_generic::<genericNullifiers>(packedErcAddress, idRemainder,\
        nullifiers[1..N], roots[1..N], nullifiersValue[1..N], oldCommitmentsSalt[1..N],\
        paths[1..N], orders[1..N], keys.nullifierKey, keys.zkpPublicKey, feeAddress));

    //Verify new Commmitments
    assert(verify_commitments::<1>(packedErcAddress, idRemainder, commitments[0..1],\
    commitmentsValue[0..1], newCommitmentsSalt[0..1], recipientPublicKey[0..1]));

    u32 genericCommitments = C - 1;
    assert(verify_commitments_generic::<genericCommitments>(packedErcAddress, idRemainder, commitments[1..C],\
    commitmentsValue[1..C], newCommitmentsSalt[1..C], recipientPublicKey[1..C], feeAddress));

    //Verify Changes
    assert(commitmentsValue[C - 2] == 0 || keys.zkpPublicKey == recipientPublicKey[C - 2]);
    
     //Verify Fee change
    assert(commitmentsValue[C - 1] == 0 || keys.zkpPublicKey == recipientPublicKey[C - 1]);

    //Verify Kem Dem encryption
    assert(verify_encryption(ercAddress,tokenId, compressedSecrets,\
        packedErcAddress,idRemainder,commitmentsValue[0],newCommitmentsSalt[0],\
        recipientPublicKey[0],recipientAddress, ephemeralKey));

    return true;
}
