from "../utils/structures.zok" import Point, PublicTransaction, Nullifiers, Commitments, Transfer, SHIFT;
from "../utils/calculations.zok" import sum;
from "../utils/calculateKeys.zok" import Keys, main as calculateKeys;
from "../casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "../casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "../verifiers/verify_duplicates.zok" import main as verify_duplicates;
from "../verifiers/verify_encryption.zok" import main as verify_encryption;
from "../verifiers/nullifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "../verifiers/nullifiers/verify_nullifiers_generic.zok" import main as verify_nullifiers_generic;
from "../verifiers/commitments/verify_commitments.zok" import main as verify_commitments;
from "../verifiers/commitments/verify_commitments_generic.zok" import main as verify_commitments_generic;
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8;

def withdraw_generic<N,C>(\
    field value,\
    field fee,\
	field tokenType,\
	field[N] historicRootBlockNumberL2,\
	u32[8] tokenId,\
	field ercAddress,\
	u32[8] recipientAddress,\
	field[C] commitments,\
	field[N] nullifiers,\
	field[2] compressedSecrets,\
    field[N] roots,\
    field feeAddress,\
    private field rootKey,\
    private u8[N][31] oldCommitmentsValue,\
 	private field[N] oldCommitmentsSalt,\
    private field[N][32] paths,\
	private field[N] orders,\
    private u8[C][31] newCommitmentsValue,\
 	private field[C] newCommitmentsSalt,\
    private Point[C] recipientPublicKey\
) -> bool {
    
    //Verify public transaction structure
    assert(ercAddress != 0);
    assert(recipientAddress != field_to_u32_8(0));
  
    //Check that combination id and value matches the token type
    //ERC20 -> Value > 0 and Id == 0
    //ERC721 -> Value == 0
    //ERC1155 -> Value > 0
    field id = u32_array_to_field(tokenId);
    assert((tokenType == 0 && value != 0 && id == 0)\
        ||  (tokenType == 1 && value == 0)\
        ||  (tokenType == 2 && value != 0));
    
    assert(compressedSecrets[0] == 0 && compressedSecrets[1] == 0);
    assert(nullifiers[0] != 0);

    //Verify duplicates
    assert(verify_duplicates::<N,C>(commitments, nullifiers));

    field[N] nullifiersValue = u8_array_to_field(oldCommitmentsValue);
    field[C] commitmentsValue = u8_array_to_field(newCommitmentsValue);

    //Check that values match
     assert(sum(nullifiersValue) == sum(commitmentsValue) + fee + value); 
    
    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = u32_array_to_field(tokenId[1..8]);
    field packedErcAddress = ercAddress + u32_array_to_field([tokenId[0]]) * SHIFT; 

    //Calculate Keys
    Keys keys = calculateKeys(rootKey);

    //Verify nullifiers
    assert(verify_nullifiers::<1>(packedErcAddress, idRemainder,\
        nullifiers[0..1], roots[0..1], nullifiersValue[0..1], oldCommitmentsSalt[0..1],\
        paths[0..1], orders[0..1], keys.nullifierKey, keys.zkpPublicKey));

    u32 genericNullifiers = N - 1;
    assert(verify_nullifiers_generic::<genericNullifiers>(packedErcAddress, idRemainder,\
        nullifiers[1..N], roots[1..N], nullifiersValue[1..N], oldCommitmentsSalt[1..N],\
        paths[1..N], orders[1..N], keys.nullifierKey, keys.zkpPublicKey, feeAddress));

    //Verify new Commmitments
    assert(verify_commitments_generic::<C>(packedErcAddress, idRemainder, commitments,\
    commitmentsValue, newCommitmentsSalt, recipientPublicKey, feeAddress));

    //Verify Changes
    assert(commitmentsValue[C - 2] == 0 || keys.zkpPublicKey == recipientPublicKey[C - 2]);
    
     //Verify Fee change
    assert(commitmentsValue[C - 1] == 0 || keys.zkpPublicKey == recipientPublicKey[C - 1]);

    return true;
}
