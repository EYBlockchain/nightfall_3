from "./common/utils/structures.zok" import BillOfMaterials, Point, SHIFT, Commitments, Nullifiers, PublicTransaction;
from "signatures/verifyEddsa.zok" import main as verifyEdDSA;
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8;
from "utils/casts/u32_to_bits.zok" import main as u32_to_bits;
from "./common/casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "./common/generic_circuit/Verifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "./common/casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "./common/generic_circuit/Verifiers/verify_structure.zok" import main as verify_structure;
from "./common/generic_circuit/Verifiers/verify_commitments.zok" import main as verify_commitments;

const u32 NUM_NULLIFIERS = 3;
const u32 NUM_COMMITMENTS = 4;

def main(\
    PublicTransaction<NUM_NULLIFIERS,NUM_COMMITMENTS> tx,\
    field[NUM_NULLIFIERS] roots,\
    field maticAddress,\
    private Nullifiers<NUM_NULLIFIERS> nullifiers,\
    private Commitments<NUM_COMMITMENTS> commitments,\
    private u32[NUM_NULLIFIERS][8] tokenIds,\
    private u32[NUM_NULLIFIERS][8] ercAddress,\
    private u32 recipeIndex\
) -> () {

    BillOfMaterials<NUM_NULLIFIERS>[2] bomList = [
        // BillOfMaterials {
        //     partQty: [ ...[1,2,3], ...[0; 7]],
        //     partNumber: [ ...[5,6,7], ...[0;7]],
        //     outputPartNumber: 1,
        // },
        // BillOfMaterials {
        //     partQty: [ ...[1,2,3], ...[0; 7]],
        //     partNumber: [ ...[5,6,7], ...[0;7]],
        //     outputPartNumber: 1,
        // }
        BillOfMaterials {
            partQty: [ ...[60], ...[0; NUM_NULLIFIERS - 1]],
            partNumber: [ ...[5], ...[0; NUM_NULLIFIERS - 1]],
            outputPartNumber: 12,
        },
        BillOfMaterials {
            partQty: [ ...[60], ...[0; NUM_NULLIFIERS - 1]],
            partNumber: [ ...[5], ...[0; NUM_NULLIFIERS - 1]],
            outputPartNumber: 12,
        }
    ];

    BillOfMaterials<NUM_NULLIFIERS> bom = bomList[recipeIndex];

    field[NUM_NULLIFIERS] nullifiersValue = u8_array_to_field(nullifiers.oldCommitments.value);
    field[NUM_COMMITMENTS] commitmentsValue = u8_array_to_field(commitments.newCommitments.value);

    for u32 i in 0..NUM_NULLIFIERS {

        u32[2] batchNumber = tokenIds[i][0..2];
        u32[2] partNumber = ercAddress[i][0..2];
        u32[2] docNumber = ercAddress[i][2..4];
        u32[2] topSig = ercAddress[i][5..7];
        assert(u32_to_bits(ercAddress[i][7])[0..8] == [...[false,false], ...[true; 6]]);


        u32[8] sig = [...topSig, ...tokenIds[i][2..8]];
        // Check partQty
        bool partQtyCheck = if(bom.partQty[i] != 0 ) {\
            bom.partQty[i] > commitmentsValue[i]\
        } else {true};

        assert(partQtyCheck);

        bool partNumberCheck = if(bom.partQty[i] != 0 ) {\
            bom.partNumber[i] == u32_array_to_field(partNumber)\
        } else {true};

        field idRemainder = u32_array_to_field(tokenIds[i][1..8]);
        field packedErcAddress = u32_array_to_field(ercAddress[i]) + u32_array_to_field([tokenIds[i][0]]) * SHIFT;

        Point firstInputZkpPublicKeys = verify_nullifiers::<1,NUM_NULLIFIERS>(packedErcAddress, idRemainder,\
        tx.nullifiers, roots, nullifiersValue, nullifiers.oldCommitments.salt,\
        nullifiers.rootKey, nullifiers.paths, nullifiers.orders, maticAddress);

        assert(verify_commitments::<1,NUM_COMMITMENTS>(packedErcAddress, idRemainder, tx.commitments,\
        commitmentsValue, commitments.newCommitments.salt, commitments.recipientPublicKey,\
        maticAddress));

    }
    return;
}