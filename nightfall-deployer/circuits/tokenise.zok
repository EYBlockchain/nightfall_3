from "./common/utils/structures.zok" import Point, PublicTransaction, Commitments, Nullifiers, SHIFT;
from "./common/utils/calculations.zok" import sum;
from "./common/casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "./common/utils/calculateKeys.zok" import Keys, main as calculateKeys;
from "./common/casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "./common/verifiers/verify_duplicates.zok" import main as verify_duplicates;
from "./common/verifiers/commitments/verify_commitments.zok" import main as verify_commitments;
from "./common/verifiers/commitments/verify_commitments_optional.zok" import main as verify_commitments_optional;
from "./common/verifiers/nullifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "./common/verifiers/nullifiers/verify_nullifiers_optional.zok" import main as verify_nullifiers_optional;
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256;
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8;


const u32 C = 2; // Number of Commitments
const u32 N = 2; // Number of Nullifiers

def main(\
    PublicTransaction<N,C> tx,\
    field[N] roots,\
    field feeAddress,\
    private field rootKey,\
    private Nullifiers<N> nullifiersInfo,\
    private Commitments<C> commitmentsInfo,\
    private field ercAddress,\
    private u32[8] tokenId\
) {
    //Verify public transaction structure
    // In Tokenise we expect the following are zeroes
    assert(tx.ercAddress == 0);
    assert(tx.recipientAddress == field_to_u32_8(0));
    assert(tx.value == 0);

    assert(tx.compressedSecrets[0] == 0 && tx.compressedSecrets[1] == 0);

    assert(tx.commitments[0] != 0);

    //Verify duplicates
    assert(verify_duplicates::<N,C>(tx.commitments, tx.nullifiers));

    field[N] nullifiersValue = u8_array_to_field(nullifiersInfo.oldCommitments.value);
    field[C] commitmentsValue = u8_array_to_field(commitmentsInfo.newCommitments.value);
    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)

    bool[256] ercAddressBits = field_to_bool_256(ercAddress);
    assert(ercAddressBits[2..4] == [true; 2]);

    field idRemainder = u32_array_to_field(tokenId[1..8]);
    field packedErcAddress = ercAddress + u32_array_to_field([tokenId[0]]) * SHIFT;

    //Calculate Keys
    Keys keys = calculateKeys(rootKey);

    // Verify nullifiers used to pay for fees
    assert(verify_nullifiers_optional::<N>(feeAddress, 0,\
        tx.nullifiers, roots, nullifiersValue, nullifiersInfo.oldCommitments.salt,\
        nullifiersInfo.paths, nullifiersInfo.orders, keys.nullifierKey, keys.zkpPublicKey));

    //Verify new Commmitments
    assert(verify_commitments::<1>(packedErcAddress, idRemainder, tx.commitments[0..1],\
        commitmentsValue[0..1], commitmentsInfo.newCommitments.salt[0..1], commitmentsInfo.recipientPublicKey[0..1]));

    // Verify change commitments from fees
    u32 feeCommitments = C - 1;
    assert(verify_commitments_optional::<feeCommitments>(feeAddress, 0, tx.commitments[1..C],\
        commitmentsValue[1..C], commitmentsInfo.newCommitments.salt[1..C], commitmentsInfo.recipientPublicKey[1..C]));

     // Verify Fee change address
    assert(commitmentsValue[C - 1] == 0 || keys.zkpPublicKey == commitmentsInfo.recipientPublicKey[C - 1]);
}

