from "hashes/poseidon/poseidon.zok" import main as poseidon

// Inputs for main:
// - ercContractAddress (public) is the ERCx contract address
// - value (public) is the 256 bit value (fungible) or identifier (non-fungible)
// - publicKey (private) is the public key of the newCommitment derived by hashing the Secret Key Sk of the newCommitment. IT IS KEPT PRIVATE!!
// - salt (private) is the salt for the newCommitment
// - newCommitment (public) is the newCommitment

struct CompressedPoint {
	field parity
	field ordinate
}

// we encode the tokenId as two fields.  The 'top4Bytes' field contains the upper 32 bits,
// the 'remainder' field contains the rest of the number
struct u256 {
	field top4Bytes
	field remainder
}

// 2 ^ 161
const field SHIFT = 2923003274661805836407369665432566039311865085952

def main(\
	field ercContractAddress,\
	u256 id,\
 	field value,\
	private CompressedPoint compressedPkd,\
	private field salt,\
	field newCommitment\
)->():

	// pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
	field packedErcAddress = ercContractAddress + id.top4Bytes * SHIFT

	// check that the parity bit is indeed a single bit. Not certain this is required but it's
	// a very low-cost validation
	assert (compressedPkd.parity * ( 1 - compressedPkd.parity) == 0)

	field newCommitmentCheck = poseidon([
		packedErcAddress,\
		id.remainder,\
		value,\
		compressedPkd.parity,\
		compressedPkd.ordinate,\
		salt\
	])
	assert(newCommitmentCheck == newCommitment)

	return
