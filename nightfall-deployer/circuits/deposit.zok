from "./common/hashes/sha256/pad1280ThenHash.zok" import main as sha256of1280
from "./common/hashes/sha256/pad1024ThenHash.zok" import main as sha256of1024
from "utils/casts/u32_8_to_bool_256.zok" import main as u32_8_to_bool_256
from "utils/pack/bool/pack256.zok" import main as bool_256_to_field

// Inputs for main:
// - ercContractAddress (public) is the ERCx contract address
// - value (public) is the 256 bit value (fungible) or identifier (non-fungible)
// - publicKey (private) is the public key of the newCommitment derived by hashing the Secret Key Sk of the newCommitment. IT IS KEPT PRIVATE!!
// - salt (private) is the salt for the newCommitment
// - newCommitment (public) is the newCommitment

def main(\
	field publicInputsHash,\
	private u32[8] ercContractAddress,\
	private u32[8] id,\
 	private u32[8] value,\
	private u32[8] compressedPkd,\
	private u32[8] salt,\
	private u32[8] newCommitment\
)->():

	// validate the new commitment:
	assert(newCommitment == sha256of1280([\
		...ercContractAddress,\
		...id,\
		...value,\
		...compressedPkd,\
		...salt\
	]))

	// Check that the 'public inputs' hash to the publicInputHash:
	// Check that the 'public inputs' hash to the publicInputHash:
	u32[8] publicInputsHashU32 = sha256of1024([\
			...ercContractAddress,\
			...id,\
			...value,\
			...newCommitment\
	])
	bool[256] publicInputsHashBool256 = u32_8_to_bool_256(publicInputsHashU32)
	bool[256] publicInputsHashBool256Sliced = [\
        ...[false; 8],\
        ...publicInputsHashBool256[8..256]\
    ]
	assert(publicInputsHash == bool_256_to_field(publicInputsHashBool256Sliced))

	return

//6234592132959175317596924428400984307908564907373992149777144831307657882 0 0 0 3786913876 4053413099 4184556347 2734706904 2298878123 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 613693392 2233983275 3493295785 2174815005 1918572955 2057629557 602582020 2658039085 846410024 553406102 3908470306 3415575930 104474189 3484707291 572485059 1756264856 770813179 475793042 2452116161 57212553 1047981885 1150177681 1598238119 3867286495
