from "ecc/babyjubjubParams" import BabyJubJubParams
from "ecc/babyjubjubParams" import main as curveParams
from "ecc/edwardsScalarMult" import main as scalarMult
from "ecc/edwardsCompress" import main as edwardsCompress
from "./common/encryption/el-gamal4" import main as enc4

from "utils/casts/u32_8_to_bool_256.zok" import main as u32_8_to_bool_256
from "utils/casts/bool_256_to_u32_8.zok" import main as bool_256_to_u32_8
from "utils/pack/bool/pack256.zok" import main as bool_256_to_field
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/pack256.zok" import main as u32_8_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8

from "./common/hashes/mimc/mimc-hash-2.zok" import main as mimc2
from "./common/hashes/sha256/pad512ThenHash.zok" import main as sha256of512
from "./common/hashes/sha256/pad1280ThenHash.zok" import main as sha256of1280
from "./common/hashes/sha256/pad4096ThenHash.zok" import main as sha256of4096

from "./common/merkle-tree/mimc-path-check.zok" import main as pathCheck

struct OldCommitment {
	u32[8] ercAddress
	u32[8] id
	u32[8] value
	u32[8] salt
	u32[8] hash
	field ask
}

struct NewCommitment {
	field[2] pkdRecipient
	u32[8] value
	u32[8] salt
	u32[8] hash
}

struct Nullifier {
	u32[8] nsk
	u32[8] hash
}

struct Secrets {
	u32[8] ephemeralKey1
	u32[8] ephemeralKey2
	u32[8] ephemeralKey3
	u32[8] ephemeralKey4
	field[16] cipherText
	field sqrtMessage1
	field sqrtMessage2
	field sqrtMessage3
	field sqrtMessage4
}

def main(\
	OldCommitment[2] oldCommitment,\
	NewCommitment[2] newCommitment,\
	Nullifier[2] nullifier,\
	field[2][33] path,\
	field[2] order,\
	private Secrets secrets\
)->():

	BabyJubJubParams context = curveParams()
	field[2] g = [context.Gu, context.Gv]

	// Calculation of ivk from ask and nsk
	field nsk = u32_8_to_field(nullifier[0].nsk)
	field ivk = mimc2([oldCommitment[0].ask, nsk])
	bool[256] ivkBool = field_to_bool_256(ivk)
	field[2] pkd = scalarMult(ivkBool, g, context)
	bool[256] nskBool = u32_8_to_bool_256(nullifier[0].nsk)
	bool[256] pkdBool = edwardsCompress(pkd)
	u32[8] pkdU32 = bool_256_to_u32_8(pkdBool)

	assert(oldCommitment[1].ask == oldCommitment[0].ask)

	// Convert (x,y) public key of recipient to a single element using Edwards compress
	// Recipient (x,y) form public key is used for encryption input while single element
	// is used for commitment inputs
	bool[256] pkdRecipientBool = edwardsCompress(newCommitment[0].pkdRecipient)
	u32[8] pkdRecipientU32 = bool_256_to_u32_8(pkdRecipientBool)
	assert(newCommitment[1].pkdRecipient == pkd)

	// Check the commitment value will not overflow we do this by only allowing
	// the value to be <224 bits (Most Significant U32 = 0). TODO is it worth
	// passing it in, should we allow more than 224 bits, might be a bit more
	// efficient?
	assert(oldCommitment[0].value[0] == 0x00000000)
	assert(oldCommitment[1].value[0] == 0x00000000)
	assert(newCommitment[0].value[0] == 0x00000000)
	assert(newCommitment[1].value[0] == 0x00000000)

	// check the summation is correct
	assert(\
		u32_8_to_field(oldCommitment[0].value) +\
		u32_8_to_field(oldCommitment[1].value) ==\
		u32_8_to_field(newCommitment[0].value) +\
		u32_8_to_field(newCommitment[1].value)\
	)

	// check the two old commitments relate to the same ERC contract
	assert(oldCommitment[0].ercAddress == oldCommitment[1].ercAddress)
	// and are of the same type (they might not be for ERC1155)
	assert(oldCommitment[0].id == oldCommitment[1].id)
	// commitments can never be equal
	assert(newCommitment[0].hash != newCommitment[1].hash)
	// nullifiers can never be equal
	assert(nullifier[0].hash != nullifier[1].hash)

	// check the nullifiers are valid
	for u32 i in 0..2 do
		u32[8] sha = sha256of512([\
			...nullifier[i].nsk,\
			...oldCommitment[i].hash\
		])
		assert(sha == nullifier[i].hash)
	endfor

	// check the new commitment for recipient is valid
	u32[8] sha = sha256of1280([\
		...oldCommitment[0].ercAddress,\
		...oldCommitment[0].id,\
		...newCommitment[0].value,\
		...pkdRecipientU32,\
		...newCommitment[0].salt\
	])
	assert(sha == newCommitment[0].hash )

	// check the new commitment for sender is valid
	sha = sha256of1280([\
		...oldCommitment[1].ercAddress,\
		...oldCommitment[1].id,\
		...newCommitment[1].value,\
		...pkdU32,\
		...newCommitment[1].salt\
	])
	assert(sha == newCommitment[1].hash )

	// check the old commitments are valid
	for u32 i in 0..2 do
		sha = sha256of1280([\
			...oldCommitment[i].ercAddress,\
			...oldCommitment[i].id,\
			...oldCommitment[i].value,\
			...pkdU32,\
			...oldCommitment[i].salt\
		])
		assert(sha == oldCommitment[i].hash)
	endfor

	// And the encryption of the transaction (extend the value up to 256 bits)
	assert(secrets.cipherText == enc4(oldCommitment[0].ercAddress, oldCommitment[0].id, newCommitment[0].value, newCommitment[0].salt, newCommitment[0].pkdRecipient, secrets.ephemeralKey1, secrets.ephemeralKey2, secrets.ephemeralKey3, secrets.ephemeralKey4, secrets.sqrtMessage1, secrets.sqrtMessage2, secrets.sqrtMessage3, secrets.sqrtMessage4))

	// check that the old commitments are in the merkle tree
	for u32 i in 0..2 do
		field mimcHash = u32_8_to_field(oldCommitment[i].hash)
		assert(pathCheck(path[i], order[i], mimcHash))
	endfor

	return

	// 0 0 0 3786913876 4053413099 4184556347 2734706904 2298878123 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 624261939 2684115311 339327711 88792873 3928934397 520906650 2317258805 3728058930 354702572 4222728155 1337313141 1064095590 1439546145 994860152 2960015781 2673279327 20554508024765599754681452527149817852616693887653983104651939102134258746269 0 0 0 3786913876 4053413099 4184556347 2734706904 2298878123 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 304542480 1555826699 3974154529 275562342 3760125967 3546966259 3993757441 4146684938 299162623 1338274655 65501719 2692461809 469162276 537606093 1445661210 3963746484 20554508024765599754681452527149817852616693887653983104651939102134258746269 5802437327018723451811518326856862491419038055833342930237171188300450891104 16545141132325711407992161993640323748633157389744839797864940876527209182509 0 0 0 0 0 0 0 12 487518454 353487348 611800095 1232537508 1944204323 2630423877 2415008051 3327339952 388581670 13088404 2689653353 4004435113 1260858943 3175608697 3566946237 2933809095 5802437327018723451811518326856862491419038055833342930237171188300450891104 16545141132325711407992161993640323748633157389744839797864940876527209182509 0 0 0 0 0 0 0 8 233887410 3765821465 2121346858 3622759640 2407054881 561077793 2974827502 939474698 384103565 2290585735 1897773673 1104920320 2789908730 571186990 4040599219 495364042 60165613 1853956399 2123184558 1150957582 2995252443 2268101302 4050509027 3488140304 943997007 2389715860 3417087801 3796716009 1419918699 2819290356 2534170482 40823723 60165613 1853956399 2123184558 1150957582 2995252443 2268101302 4050509027 3488140304 1903579183 784505298 4260141523 2670681018 3199382950 1166191552 3318597421 1784396345 10229752444226998556521993323162993622768786902328447893774968691084615383825 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19580269025233800232942214267900605243953356825844273875865014642655032796447 15636263341351711724975016994043416901792637180555068604488690081854031458394 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 13951531544348673269400720537311387247715263843017456944493996457606504233631 18173147751328346181790560276168602461355682327527941374661483569583480458430 17305715846932434849336906769371255311144578441086085710047989562338158800916 1 7 2359987415 3159296369 526688326 4098551049 1528042895 882708874 4245753676 1935164289 2817261640 3760954993 2612944283 559246575 1370911030 1687193153 1496828142 2427206239 3256759789 538907110 2277888369 2314224439 24838256 1346923435 3422386420 1217685781 3390692807 266150744 2675177352 3755135292 1779594036 4293817250 3344666214 3588566237 1175020188808840257343063331507245114506288533413708927291085226502134368526 14568839371082838726366810835094090888864989738978198066001379142349317379990 9100378918016199466638354160965654838900336615484419072446457716818406884810 16431156242194432241521204799091732533967538080821784300268077594333730701597 9257708006239700464097272409709043491310875044255348949778106876332746342124 7473053417393365483910988333391592883783716407806974234768265471504275504839 2012549455465367523567288835247989602574849842009210548845984586526544659263 3092571444336375706526156884504887873968326249871961471629510866757709229616 5212571345892668357729106747746693994627555625817379853291920007315855988953 1860673232941305503386574547452404710116074001233841070050150560753560397732 21318291593716638861244902688655871285988667537071398351648493402582736440613 15172294032040446997196215245331164850103216436478379233296072962760843823404 9299901399537518824024853966808139320345847940976495941521627312190961746508 14650677491131141982946400769208130223733600436336979726551480106518703014370 21803130863795418945950807470940239677711397577722661753669693395365800997154 5956917725501239183093277853672945256231403521010612481620086269603440489140 9427050129567031675553048604712181295465196374683565284398992208923945768094 0 60102829190319644835548050675648710959043900249173724935020008846436767741 10658822520318240111760746778142470355846485455867167192309711466410050757301
