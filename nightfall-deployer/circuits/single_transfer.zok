from "ecc/babyjubjubParams" import BabyJubJubParams
from "ecc/babyjubjubParams" import main as curveParams
from "ecc/edwardsScalarMult" import main as scalarMult
from "ecc/edwardsCompress" import main as edwardsCompress
from "./common/encryption/el-gamal4" import main as enc4
from "hashes/poseidon/poseidon.zok" import main as poseidon
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "./common/hashes/mimc/mimc-hash-2.zok" import main as mimc2
from "./common/merkle-tree/mimc-path-check.zok" import main as pathCheck
from "./common/casts/u8_array_to_field.zok" import main as u8_array_to_field
from "./common/casts/u32_array_to_field.zok" import main as u32_array_to_field

type Point = field[2]

// 2 ^ 161
const field SHIFT = 2923003274661805836407369665432566039311865085952

struct OldCommitmentPreimage {
	u32[8] id
	u8[31] value // needed to prevent overflow attacks in transfers
	field salt
	field hash
	field ask
}

struct NewCommitmentPreimage {
	Point pkdRecipient
	u8[31] value
	field salt
}

struct Secrets {
	u32[8] ephemeralKey1
	u32[8] ephemeralKey2
	u32[8] ephemeralKey3
	u32[8] ephemeralKey4
	field[16] cipherText
	field sqrtMessage1
	field sqrtMessage2
	field sqrtMessage3
	field sqrtMessage4
}

struct CompressedPoint {
	bool parity
	field ordinate
}

def main(\
	private field ercAddress,\
	private OldCommitmentPreimage oldCommitment,\
	private NewCommitmentPreimage newCommitment,\
	field newCommitmentHash,\
	private field nsk,\
	field nullifier,\
	field root,\
	private field[32] path,\
	private field order,\
	private Secrets secrets,\
	CompressedPoint[8] compressedCipherText\
)->():

	BabyJubJubParams context = curveParams()
	field[2] g = [context.Gu, context.Gv]

	// Calculation of ivk from ask and nsk
	field ivk = mimc2([oldCommitment.ask, nsk])
	bool[256] ivkBool = field_to_bool_256(ivk)
	field[2] pkd = scalarMult(ivkBool, g, context)

	// check the nullifier is valid
	field nullifierCheck = poseidon([nsk, oldCommitment.hash])
	assert (nullifierCheck == nullifier)

	// check the new commitment is valid
	// we effectively throw away the value of the new commitment by insisting
	// that it is equal to the old commitment value for a single-token transfer
	// This is a little inefficient but makes the witness computation in node
	// independent of how many commitments are being transformed.
	assert(newCommitment.value == oldCommitment.value)
	field value = u8_array_to_field(oldCommitment.value)
	// pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
	field idTop4Bytes = u32_array_to_field([oldCommitment.id[0]])
	field idRemainder = u32_array_to_field(oldCommitment.id[1..8])
	field packedErcAddress = ercAddress + idTop4Bytes * SHIFT

	field newCommitmentCheck = poseidon([\
		packedErcAddress,\
		idRemainder,\
		value,\
		...newCommitment.pkdRecipient,\
		newCommitment.salt\
	])
	assert (newCommitmentCheck == newCommitmentHash)

	// check the old commitment is valid
	field oldCommitmentCheck = poseidon([\
		packedErcAddress,\
		idRemainder,\
		value,\
		...pkd,\
		oldCommitment.salt\
	])
	assert(oldCommitmentCheck == oldCommitment.hash)

	// check that the old commitment is in the merkle tree (path[0] should be the root)
	field mimcHash = oldCommitment.hash
	bool x = pathCheck([root, ...path], order, mimcHash)
	assert(x)

	// And the encryption of the transaction (extend the value up to 256 bits)
	assert(secrets.cipherText == enc4(packedErcAddress, idRemainder, value, newCommitment.salt, newCommitment.pkdRecipient , secrets.ephemeralKey1, secrets.ephemeralKey2, secrets.ephemeralKey3, secrets.ephemeralKey4, secrets.sqrtMessage1, secrets.sqrtMessage2, secrets.sqrtMessage3, secrets.sqrtMessage4))

	// check the compressed cipherText
	// we pass in 8x compressed points rather than 16x uncompressed points to save time / gas
	for u32 i in 0..8 do
		// these intermediate vars really speed up compile time
		// there is likely a compiler bug with zokrates 0.6.4 which makes using spreads (e.g. [8..256]) inside a function (e.g. assert()) very slow
		u32 j = 2*i
		bool[256] compressed256 = edwardsCompress([secrets.cipherText[j], secrets.cipherText[j+1]])
		bool parity = compressedCipherText[i].parity
		bool[256] ordinate = field_to_bool_256(compressedCipherText[i].ordinate)
		bool[256] compressedCheck256 = [ parity, ...ordinate[1..256] ]
		assert(compressed256 == compressedCheck256)
	endfor

	return
