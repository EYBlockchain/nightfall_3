from "ecc/babyjubjubParams" import BabyJubJubParams
from "ecc/babyjubjubParams" import main as curveParams
from "ecc/edwardsScalarMult" import main as scalarMult
from "ecc/edwardsCompress" import main as edwardsCompress
from "./common/encryption/kem-dem.zok" import main as kemDem, EncryptedMsgs

from "utils/casts/u32_to_bits.zok" import main as u32_to_bool_32
from "utils/casts/bool_256_to_u32_8.zok" import main as bool_256_to_u32_8
from "utils/casts/u32_8_to_bool_256.zok" import main as u32_8_to_bool_256
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/pack256.zok" import main as u32_8_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8

from "./common/hashes/mimc/mimc-hash-2.zok" import main as mimc2
from "./common/hashes/sha256/pad512ThenHash.zok" import main as sha256of512
from "./common/hashes/sha256/pad1280ThenHash.zok" import main as sha256of1280

from "./common/merkle-tree/mimc-path-check.zok" import main as pathCheck

struct OldCommitmentPreimage {
	u32[8] id
	u32[8] value
	u32[8] salt
	u32[8] hash
	field rootKey
}

struct NewCommitmentPreimage {
	field[2] zkpPublicKeyRecipient
	u32[8] value
	u32[8] salt
}

struct CompressedPoint {
	bool parity
	field ordinate
}

def main(\
	private field[2] fErcAddress,\
	private OldCommitmentPreimage[2] oldCommitment,\
	private NewCommitmentPreimage[2] newCommitment,\
	field[2] fNewCommitmentHash,\
	field[2] fNullifier,\
	field[2] root,\
	private field[2][32] path,\
	private field[2] order,\
	private u32[8] ephemeralKey,\
	CompressedPoint compressedEphemeralPublicKey,\
	field[4] cipherText\
)->():

	BabyJubJubParams context = curveParams()
	field[2] g = [context.Gu, context.Gv]

	// Calculation of zkpPrivateKey and nullifierKey from rootKey
	field[2] zkpPrivateKey = [mimc2([oldCommitment[0].rootKey, 2708019456231621178814538244712057499818649907582893776052749473028258908910]),  mimc2([oldCommitment[1].rootKey, 2708019456231621178814538244712057499818649907582893776052749473028258908910])]
	field[2] nullifierKey = [mimc2([oldCommitment[0].rootKey, 7805187439118198468809896822299973897593108379494079213870562208229492109015]), mimc2([oldCommitment[1].rootKey, 7805187439118198468809896822299973897593108379494079213870562208229492109015])]
	u32[2][8] nullifierKeyU328 = [field_to_u32_8(nullifierKey[0]), field_to_u32_8(nullifierKey[1])] //this

	bool[2][256] zkpPrivateKeyBool = [field_to_bool_256(zkpPrivateKey[0]), field_to_bool_256(zkpPrivateKey[1])]
	field[2][2] zkpPublicKey = [scalarMult(zkpPrivateKeyBool[0], g, context), scalarMult(zkpPrivateKeyBool[1], g, context)] //this
	bool[2][256] zkpPublicKeyBool = [edwardsCompress(zkpPublicKey[0]), edwardsCompress(zkpPublicKey[1])]
	u32[2][8] zkpPublicKeyU32 = [bool_256_to_u32_8(zkpPublicKeyBool[0]), bool_256_to_u32_8(zkpPublicKeyBool[1])] //this

	// we convert the types to hash friendly u32s
	u32[2][8] ercAddress = [field_to_u32_8(fErcAddress[0]), field_to_u32_8(fErcAddress[1])]
	u32[2][8] newCommitmentHash = [field_to_u32_8(fNewCommitmentHash[0]), field_to_u32_8(fNewCommitmentHash[1])]
	u32[2][8] nullifier = [field_to_u32_8(fNullifier[0]), field_to_u32_8(fNullifier[1])]

	// Convert (x,y) public key of recipient to a single element using Edwards compress
	// Recipient (x,y) form public key is used for encryption input while single element
	// is used for commitment inputs
	bool[256] zkpPublicKeyRecipientBool = edwardsCompress(newCommitment[0].zkpPublicKeyRecipient)
	u32[8] zkpPublicKeyRecipientU32 = bool_256_to_u32_8(zkpPublicKeyRecipientBool)
	assert(newCommitment[1].zkpPublicKeyRecipient == zkpPublicKey[0])

	// Check the commitment value will not overflow we do this by only allowing
	// the value to be <224 bits (Most Significant U32 = 0). TODO is it worth
	// passing it in, should we allow more than 224 bits, might be a bit more
	// efficient?
	assert(oldCommitment[0].value[0] == 0x00000000)
	assert(oldCommitment[1].value[0] == 0x00000000)
	assert(newCommitment[0].value[0] == 0x00000000)
	assert(newCommitment[1].value[0] == 0x00000000)

	// check the summation is correct
	assert(\
		u32_8_to_field(oldCommitment[0].value) +\
		u32_8_to_field(oldCommitment[1].value) ==\
		u32_8_to_field(newCommitment[0].value) +\
		u32_8_to_field(newCommitment[1].value)\
	)

	// check the two old commitments relate to the same ERC contract
	assert(ercAddress[0] == ercAddress[1])
	// and are of the same type (they might not be for ERC1155)
	assert(oldCommitment[0].id == oldCommitment[1].id)
	// commitments can never be equal
	assert(newCommitmentHash[0] != newCommitmentHash[1])
	// nullifiers can never be equal
	assert(nullifier[0] != nullifier[1])

	// check the nullifiers are valid
	for u32 i in 0..2 do
		u32[8] sha = sha256of512([\
			...nullifierKeyU328[i],\
			...oldCommitment[i].hash\
		])
		// nullifiers are truncated to 248 bits since they are public inputs
		// so we must check the 248 bits while minimising constraints/comp time - casting to bool[256] is a slower operation than comparing u32s

		// last 224 bits:
		assert(sha[1..8] == nullifier[i][1..8])
		// first 24 bits:
		assert(u32_to_bool_32(sha[0])[8..32] == u32_to_bool_32(nullifier[i][0])[8..32])
	endfor

	// check the new commitment for recipient is valid
	u32[8] sha = sha256of1280([\
		...ercAddress[0],\
		...oldCommitment[0].id,\
		...newCommitment[0].value,\
		...zkpPublicKeyRecipientU32,\
		...newCommitment[0].salt\
	])
		// new commitments are truncated to 248 bits since they are public inputs
		// so we must check the 248 bits while minimising constraints/comp time - casting to bool[256] is a slower operation than comparing u32s

		// last 224 bits:
		assert(sha[1..8] == newCommitmentHash[0][1..8])
		// first 24 bits:
		assert(u32_to_bool_32(sha[0])[8..32] == u32_to_bool_32(newCommitmentHash[0][0])[8..32])

	// check the new commitment for sender is valid
	sha = sha256of1280([\
		...ercAddress[1],\
		...oldCommitment[1].id,\
		...newCommitment[1].value,\
		...zkpPublicKeyU32[0],\
		...newCommitment[1].salt\
	])
	// new commitments are truncated to 248 bits since they are public inputs
	// so we must check the 248 bits while minimising constraints/comp time - casting to bool[256] is a slower operation than comparing u32s

	// last 224 bits:
	assert(sha[1..8] == newCommitmentHash[1][1..8])
	// first 24 bits:
	assert(u32_to_bool_32(sha[0])[8..32] == u32_to_bool_32(newCommitmentHash[1][0])[8..32])

	// check the old commitments are valid
	for u32 i in 0..2 do
		sha = sha256of1280([\
			...ercAddress[i],\
			...oldCommitment[i].id,\
			...oldCommitment[i].value,\
			...zkpPublicKeyU32[i],\
			...oldCommitment[i].salt\
		])
		// assert(sha == oldCommitment[i].hash)
		// last 224 bits:
		assert(sha[1..8] == oldCommitment[i].hash[1..8])
		// first 24 bits:
		assert(u32_to_bool_32(sha[0])[8..32] == u32_to_bool_32(oldCommitment[i].hash[0])[8..32])
	endfor

	// KEM-DEM Encryption
	bool[256] bitEphemeralKey = u32_8_to_bool_256(ephemeralKey)

	// To ensure all values are < p we move some bits around (as tokenID can be a full 256bits)
	assert(ercAddress[0][0..3] == [0x00000000,0x00000000,0x00000000]) // Make sure the leading 96bits are 0
	assert(oldCommitment[0].value[0] == 0x00000000) // Value can be up to 224 bits

	// We move the top-most 32bits from the tokenID to the ercAddress
	u32[8] packedERCAddress = [...ercAddress[0][0..2], oldCommitment[0].id[0], ...ercAddress[0][3..8]]
	u32[8] unpackedTokenID = [0x00000000, ...oldCommitment[0].id[1..8]]
	field[4] plainTexts = [\
		u32_8_to_field(packedERCAddress),\
		u32_8_to_field(unpackedTokenID),\
		u32_8_to_field(newCommitment[0].value),\
		u32_8_to_field(newCommitment[0].salt)\
	]
	EncryptedMsgs<4> enc = kemDem(bitEphemeralKey, newCommitment[0].zkpPublicKeyRecipient, plainTexts)
	assert(cipherText == enc.cipherText)

	bool[256] compressedPubKeyOutput = edwardsCompress(enc.ephemeralPublicKey)
	bool parity = compressedEphemeralPublicKey.parity
	bool[256] ordinate = field_to_bool_256(compressedEphemeralPublicKey.ordinate)
	bool[256] compressedCheck256 = [ parity, ...ordinate[1..256] ]
	assert(compressedPubKeyOutput == compressedCheck256)

	for u32 i in 0..2 do
		field mimcHash = u32_8_to_field(oldCommitment[i].hash)
		assert(pathCheck([root[i], ...path[i]], order[i], mimcHash))
	endfor

	return
