
from "../common/utils/structures.zok" import Point, SHIFT, PublicTransaction, CompressedPoint
from "../common/utils/calculations.zok" import sum
from "../common/casts/u32_array_to_field.zok" import main as u32_array_to_field
from "./Verifiers/verify_struct.zok" import main as verify_struct
from "./Verifiers/verify_structure.zok" import main as verify_structure
from "./Verifiers/verify_encryption.zok" import main as verify_encryption
from "./Verifiers/verify_nullifiers.zok" import main as verify_nullifiers
from "./Verifiers/verify_commitments.zok" import main as verify_commitments

def main<TxType, NumNullifiers, NumCommitments, Transfer>(\
    PublicTransaction tx,\
    bool[Transfer] compressedEphemeralPublicKeyParity,\
    field[Transfer] compressedEphemeralPublicKeyOrdinate,\
    private u32[Transfer][8] ephemeralKey,\
    private field packedErcAddressTransfer,\
    private field idRemainderTransfer,\
    private field[NumNullifiers] oldCommitmentValues,\
    private field[NumNullifiers] oldCommitmentSalts,\
    private field[NumNullifiers] rootKey,\
    private field[NumNullifiers][32] paths,\
	private field[NumNullifiers] orders,\
    private field[NumCommitments] newCommitmentValues,\
    private field[NumCommitments] newCommitmentSalts,\
    private Point[NumCommitments] recipientPublicKey\
)-> (bool):
    
    assert((TxType == 1 && Transfer == 1) || (TxType != 1 && Transfer == 0))
    
    //Verify public transaction structure
    //assert(verify_structure::<TxType, NumNullifiers, NumCommitments>(tx))
    assert(verify_struct::<TxType, NumNullifiers, NumCommitments>(\
        tx.value,\
	    tx.transactionType,\
	    tx.tokenType,\
	    tx.tokenId,\
	    tx.ercAddress,\
	    tx.recipientAddress,\
	    tx.commitments,\
	    tx.nullifiers,\
	    tx.historicRootBlockNumberL2,\
	    tx.compressedSecrets,\
	    tx.proof\
    ))

    //Check that values match
    field oldValues = sum(oldCommitmentValues) + if TxType == 0 then tx.value else 0 fi
    field newValues = sum(newCommitmentValues) + if TxType == 2 then tx.value else 0 fi
    assert(oldValues == newValues)

    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = if TxType == 1 then idRemainderTransfer else u32_array_to_field(tx.tokenId[1..8]) fi
    field packedErcAddress = if TxType == 1 then packedErcAddressTransfer else tx.ercAddress + u32_array_to_field([tx.tokenId[0]]) * SHIFT fi

    assert((TxType == 1 && idRemainderTransfer != 0 && packedErcAddressTransfer != 0)\
        || (TxType != 1 && idRemainderTransfer == 0 || packedErcAddressTransfer == 0))

    //Verify nullifiers
    bool valid, field[2] changeZkpPublicKeys = verify_nullifiers::<NumNullifiers>(packedErcAddress, idRemainder, tx.value,\
        tx.nullifiers, tx.historicRootBlockNumberL2, oldCommitmentValues, oldCommitmentSalts, rootKey, paths, orders)
    assert(valid)

    //Verify new Commmitments
    assert(verify_commitments::<NumCommitments, TxType>(packedErcAddress, idRemainder, tx.commitments, changeZkpPublicKeys,\
    newCommitmentValues, newCommitmentSalts, recipientPublicKey))
        
    //Verify Kem Dem encryption
    assert(verify_encryption::<NumCommitments,Transfer>(packedErcAddress, idRemainder, tx.compressedSecrets,\
        newCommitmentValues,newCommitmentSalts,recipientPublicKey,compressedEphemeralPublicKeyParity,\
        compressedEphemeralPublicKeyOrdinate, ephemeralKey))
    
    return true
