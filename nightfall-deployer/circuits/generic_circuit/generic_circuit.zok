
from "../common/utils/structures.zok" import Point, SHIFT, PublicTransaction
from "../common/utils/calculations.zok" import sum
from "../common/casts/u32_array_to_field.zok" import main as u32_array_to_field
from "./Verifiers/verify_struct.zok" import main as verify_struct
from "./Verifiers/verify_structure.zok" import main as verify_structure
from "./Verifiers/verify_encryption.zok" import main as verify_encryption
from "./Verifiers/verify_nullifiers.zok" import main as verify_nullifiers
from "./Verifiers/verify_commitments.zok" import main as verify_commitments

def main<TxType, NumNullifiers, NumCommitments, Transfer>(\
    PublicTransaction tx,\
    private field[NumNullifiers] oldCommitmentValues,\
    private field[NumNullifiers] oldCommitmentSalts,\
    private field[NumNullifiers] rootKey,\
    private field[NumNullifiers][32] paths,\
	private field[NumNullifiers] orders,\
    private field[NumCommitments] newCommitmentValues,\
    private field[NumCommitments] newCommitmentSalts,\
    private Point[NumCommitments] recipientPublicKey,\
    bool[Transfer] compressedEphemeralPublicKeyParity,\
    field[Transfer] compressedEphemeralPublicKeyOrdinate,\
    private u32[Transfer][8] ephemeralKey,\
    private field[Transfer] ercAddressTransfer,\
    private u32[Transfer][8] idTransfer\
)-> (bool):
    
    //Check that if transaction type is transfer, Transfer generic parameter is set to 1. Otherwise, check Transfer is 0
    assert((TxType == 1 && Transfer == 1) || (TxType != 1 && Transfer == 0))
    
    //Verify public transaction structure
    //assert(verify_structure::<TxType, NumNullifiers, NumCommitments>(tx))
    assert(verify_struct::<TxType, NumNullifiers, NumCommitments>(\
        tx.value,\
	    tx.transactionType,\
	    tx.tokenType,\
	    tx.tokenId,\
	    tx.ercAddress,\
	    tx.recipientAddress,\
	    tx.commitments,\
	    tx.nullifiers,\
	    tx.historicRootBlockNumberL2,\
	    tx.compressedSecrets,\
	    tx.proof\
    ))

    //Check that values match
    field oldValues = sum(oldCommitmentValues) + if TxType == 0 then tx.value else 0 fi
    field newValues = sum(newCommitmentValues) + if TxType == 2 then tx.value else 0 fi
    assert(oldValues == newValues)

    // pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
    field idRemainder = u32_array_to_field(tx.tokenId[1..8]) 
    field packedErcAddress = tx.ercAddress + u32_array_to_field([tx.tokenId[0]]) * SHIFT 

    //If TxType is a transfer, Transfer generic parameter will be set to 1 and this loop will be run once
    //Otherwise, the loop will go from 0..0 so it will never enter
    for u32 i in 0..Transfer do
        //Calculate idRemainder and packedErcAddress for a transfer transaction
        idRemainder = u32_array_to_field(idTransfer[0][1..8]) 
        packedErcAddress = ercAddressTransfer[0] + u32_array_to_field([idTransfer[0][0]]) * SHIFT 
    endfor

    //Verify nullifiers
    bool valid, field[2] changeZkpPublicKeys = verify_nullifiers::<NumNullifiers>(packedErcAddress, idRemainder, tx.value,\
        tx.nullifiers, tx.historicRootBlockNumberL2, oldCommitmentValues, oldCommitmentSalts, rootKey, paths, orders)
    assert(valid)

    //Verify new Commmitments
    assert(verify_commitments::<NumCommitments, TxType>(packedErcAddress, idRemainder, tx.commitments, changeZkpPublicKeys,\
    newCommitmentValues, newCommitmentSalts, recipientPublicKey))
        
    //Verify Kem Dem encryption
    assert(verify_encryption::<NumCommitments,Transfer>(tx.ercAddress,tx.tokenId, tx.compressedSecrets,\
        packedErcAddress,idRemainder,newCommitmentValues,newCommitmentSalts,recipientPublicKey,\
        compressedEphemeralPublicKeyParity, compressedEphemeralPublicKeyOrdinate, ephemeralKey))
    
    return true
