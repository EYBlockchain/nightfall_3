from "./common/utils/structures.zok" import Point, PublicTransaction, Commitments, Nullifiers, SHIFT;
from "./common/utils/calculations.zok" import sum;
from "./common/casts/u32_array_to_field.zok" import main as u32_array_to_field;
from "./common/utils/calculateKeys.zok" import Keys, main as calculateKeys;
from "./common/casts/u8_array_to_field.zok" import main as u8_array_to_field;
from "./common/verifiers/verify_duplicates.zok" import main as verify_duplicates;
from "./common/verifiers/commitments/verify_commitments_optional.zok" import main as verify_commitments_optional;
from "./common/verifiers/nullifiers/verify_nullifiers.zok" import main as verify_nullifiers;
from "./common/verifiers/nullifiers/verify_nullifiers_optional.zok" import main as verify_nullifiers_optional;
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256;
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8;

const u32 C = 2;
const u32 N = 3;

def main(\
    PublicTransaction<N,C> tx,\
    field[N] roots,\
    field feeAddress,\
    private field rootKey,\
    private Nullifiers<N> nullifiersInfo,\
    private Commitments<C> commitmentsInfo,\
    private field ercAddress,\
    private u32[8] tokenId,\
    private field value\
) {
     //Verify public transaction structure
    assert(tx.ercAddress == 0);
    assert(tx.recipientAddress == field_to_u32_8(0));
    assert(tx.value == 0);

    assert(tx.compressedSecrets[0] == 0 && tx.compressedSecrets[1] == 0);

    assert(tx.nullifiers[0] != 0);

    //Verify duplicates
    assert(verify_duplicates::<N,C>(tx.commitments, tx.nullifiers));

    field[N] nullifiersValue = u8_array_to_field(nullifiersInfo.oldCommitments.value);
    field[C] commitmentsValue = u8_array_to_field(commitmentsInfo.newCommitments.value);

    bool[256] ercAddressBits = field_to_bool_256(ercAddress);
    assert(ercAddressBits[2..4] == [true; 2]);

    field idRemainder = u32_array_to_field(tokenId[1..8]);
    field packedErcAddress = ercAddress + u32_array_to_field([tokenId[0]]) * SHIFT;

    //Calculate Keys
    Keys keys = calculateKeys(rootKey);

    //Check that values match
    assert(sum(nullifiersValue) == sum(commitmentsValue) + tx.fee + value); 

    //Verify nullifiers
    assert(verify_nullifiers::<1>(packedErcAddress, idRemainder,\
        tx.nullifiers[0..1], roots[0..1], nullifiersValue[0..1], nullifiersInfo.oldCommitments.salt[0..1],\
        nullifiersInfo.paths[0..1], nullifiersInfo.orders[0..1], keys.nullifierKey, keys.zkpPublicKey));

    u32 feeNullifiers = N - 1;
    assert(verify_nullifiers_optional::<feeNullifiers>(feeAddress, 0,\
        tx.nullifiers[1..N], roots[1..N], nullifiersValue[1..N], nullifiersInfo.oldCommitments.salt[1..N],\
        nullifiersInfo.paths[1..N], nullifiersInfo.orders[1..N], keys.nullifierKey, keys.zkpPublicKey));

    //Verify commitment
    assert(verify_commitments_optional::<1>(packedErcAddress, idRemainder, [tx.commitments[0]],\
        [commitmentsValue[0]], [commitmentsInfo.newCommitments.salt[0]], [commitmentsInfo.recipientPublicKey[0]]));

    //Verify commitment fee
    assert(verify_commitments_optional::<1>(feeAddress, 0, [tx.commitments[1]],\
        [commitmentsValue[1]], [commitmentsInfo.newCommitments.salt[1]], [commitmentsInfo.recipientPublicKey[1]]));

    //Verify change
    assert(commitmentsValue[C - 2] == 0 || keys.zkpPublicKey == commitmentsInfo.recipientPublicKey[C - 2]);

    //Verify Fee change
    assert(commitmentsValue[C - 1] == 0 || keys.zkpPublicKey == commitmentsInfo.recipientPublicKey[C - 1]);
}
