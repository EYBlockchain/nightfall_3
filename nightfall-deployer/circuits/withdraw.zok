from "ecc/babyjubjubParams" import BabyJubJubParams
from "ecc/babyjubjubParams" import main as curveParams
from "ecc/edwardsCompress" import main as edwardsCompress
from "ecc/edwardsScalarMult" import main as scalarMult

from "utils/casts/bool_256_to_u32_8.zok" import main as bool_256_to_u32_8
from "utils/casts/u32_to_bits.zok" import main as u32_to_bool_32
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/pack256.zok" import main as u32_8_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8
from "./common/casts/u8_array_to_field.zok" import main as u8_array_to_field
from "./common/casts/u32_array_to_field.zok" import main as u32_array_to_field

from "./common/hashes/mimc/mimc-hash-2.zok" import main as mimc2
from "./common/hashes/sha256/pad512ThenHash.zok" import main as sha256of512
from "./common/hashes/sha256/pad1280ThenHash.zok" import main as sha256of1280
from "hashes/poseidon/poseidon.zok" import main as poseidon

from "./common/merkle-tree/mimc-path-check.zok" import main as pathCheck

// 2 ^ 161
const field SHIFT = 2923003274661805836407369665432566039311865085952

struct OldCommitmentPreimage {
	field salt
	field hash
	field ask
}

def main(\
	field ercAddress,\
	u32[8] id,\
 	field value,\
	private OldCommitmentPreimage oldCommitment,\
	private field nsk,\
	field nullifier,\
	field recipientAddress,\
	field root,\
	private field[32] path,\
	private field order\
)->():

	BabyJubJubParams context = curveParams()
	field[2] g = [context.Gu, context.Gv]

	// Calculation of ivk from ask and nsk
	field ivk = mimc2([oldCommitment.ask, nsk])
	bool[256] ivkBool = field_to_bool_256(ivk)
	field[2] pkd = scalarMult(ivkBool, g, context)

	// check the nullifier is valid
	field nullifierCheck = poseidon([\
		nsk,\
		oldCommitment.hash\
	])
	assert(nullifierCheck == nullifier)

	// pack the top four bytes of the token id into the ercAddress field (address only
	// uses 160 bits and the Shield contract prevents creation of something with more than 160 bits)
	field idTop4Bytes = u32_array_to_field([id[0]])
	field idRemainder = u32_array_to_field(id[1..8])
	field packedErcAddress = ercAddress + idTop4Bytes * SHIFT

	// check the old commitment is valid
	field oldCommitmentCheck = poseidon([\
		packedErcAddress,\
		idRemainder,\
		value,\
		...pkd,\
		oldCommitment.salt\
	])
	assert(oldCommitmentCheck == oldCommitment.hash)

	// check that the old commitment is in the merkle tree
	field mimcHash = oldCommitment.hash
	assert(pathCheck([root, ...path], order, mimcHash))

	return
