from "ecc/babyjubjubParams" import BabyJubJubParams
from "ecc/babyjubjubParams" import main as curveParams
from "ecc/edwardsCompress" import main as edwardsCompress
from "ecc/edwardsScalarMult" import main as scalarMult

from "utils/casts/bool_256_to_u32_8.zok" import main as bool_256_to_u32_8
from "utils/casts/u32_to_bits.zok" import main as u32_to_bool_32
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/pack256.zok" import main as u32_8_to_field
from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8

from "./common/hashes/mimc/mimc-hash-2.zok" import main as mimc2
from "./common/hashes/sha256/pad512ThenHash.zok" import main as sha256of512
from "./common/hashes/sha256/pad1280ThenHash.zok" import main as sha256of1280

from "./common/merkle-tree/mimc-path-check.zok" import main as pathCheck

struct OldCommitmentPreimage {
	u32[8] salt
	u32[8] hash
	field ask
}

def main(\
	field fErcAddress,\
	field fId,\
 	field fValue,\
	private OldCommitmentPreimage oldCommitment,\
	private u32[8] nsk,\
	field fNullifier,\
	field recipientAddress,\
	field root,\
	private field[32] path,\
	private field order\
)->():

	BabyJubJubParams context = curveParams()
	field[2] g = [context.Gu, context.Gv]

	// Calculation of ivk from ask and nsk
	field nskField = u32_8_to_field(nsk)
	field ivk = mimc2([oldCommitment.ask, nskField])
	bool[256] ivkBool = field_to_bool_256(ivk)
	field[2] pkd = scalarMult(ivkBool, g, context)
	bool[256] pkdBool = edwardsCompress(pkd)
	u32[8] pkdU32 = bool_256_to_u32_8(pkdBool)

	u32[8] ercAddress = field_to_u32_8(fErcAddress)
	u32[8] id = field_to_u32_8(fId)
	u32[8] value = field_to_u32_8(fValue)
	u32[8] nullifier = field_to_u32_8(fNullifier)

	// check the nullifier is valid
	u32[8] sha = sha256of512([\
		...nsk,\
		...oldCommitment.hash\
	])

	// nullifiers are truncated to 248 bits since they are public inputs
	// so we must check the 248 bits while minimising constraints/comp time - casting to bool[256] is a slower operation than comparing u32s

	// last 224 bits:
	assert(sha[1..8] == nullifier[1..8])
	// first 24 bits:
	assert(u32_to_bool_32(sha[0])[8..32] == u32_to_bool_32(nullifier[0])[8..32])

	// check the old commitment is valid
	// old commitments are private inputs, so they are u32[8] and not truncated
	assert(oldCommitment.hash == sha256of1280([\
		...ercAddress,\
		...id,\
		...value,\
		...pkdU32,\
		...oldCommitment.salt\
	]))

	// check that the old commitment is in the merkle tree
	field mimcHash = u32_8_to_field(oldCommitment.hash)
	assert(pathCheck([root, ...path], order, mimcHash))

	return
// 0 0 0 3786913876 4053413099 4184556347 2734706904 2298878123 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 2219597431 1755426215 3293145557 3243256786 3816304020 1517647008 425275575 1318493102 366750885 2604783080 3623807610 4147206897 2198290470 1707590623 385867958 4233993206 20554508024765599754681452527149817852616693887653983104651939102134258746269 60165613 1853956399 2123184558 1150957582 2995252443 2268101302 4050509027 3488140304 625919956 422449450 1194504794 2151460778 3906881990 2763939802 883444624 2224534737 893705366084700132548040460931008653290460453987 6100509968277764863775768711148611107175898089815871963355773213731205366508 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 13951531544348673269400720537311387247715263843017456944493996457606504233631 0 20781082199163440865218068816821413366576335772482013527788056044402762718175 4
