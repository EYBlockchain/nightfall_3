from "utils/pack/unpack128.zok" import main as unpack128
from "../verify-membership/height128.zok" import main as calcRoot128

// @param {field} latestLeafIndex - the right-most populated leafIndex of the tree BEFORE we add any new leaves. (So the first leaf we add will be at index = latestLeafIndex + 1)
// @param {field} oldRoot - the root currently stored on-chain
// @param {field} newRoot - the new root that will replace the oldRoot
// @param {field[SUBTREE_DEPTH]} siblingPath. The siblingPath for the root of the subtree in the merkle pollard.
def main(\
    field latestLeafIndex,\
    field oldRoot,\
    field newRoot,\
    field newLeaf,\
    private field[128] siblingPath\
) -> ():
    field leftLeafIndex = latestLeafIndex + 1 // the left-most leafIndex of the batch of new leaves we wish to add (although in this circuit we're just adding one leaf).

    // prove that:
    // - the next available subtree was previously empty.
    // - the siblingPath for this pollardLeafIndex is correct, since it resolves to the oldRoot
    oldRoot == calcRoot128(siblingPath, 0, leftLeafIndex)

    newRoot == calcRoot128(siblingPath, newLeaf, leftLeafIndex)

    return
