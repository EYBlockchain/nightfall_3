from "utils/pack/unpack128.zok" import main as unpack128

from "./roots-of-zeros" import main as rootsOfZeros
from "../verify-membership/height126.zok" import main as calcRoot126

from "../../../merkle-tree-utils.zok" import leafIndexToNodeIndex as leafIndexToNodeIndex
from "../../../merkle-tree-utils.zok" import nodeIndexToLeafIndex as nodeIndexToLeafIndex

from "../../../../hashes/mimc/bls12-377/mimc2.zok" import main as mimc2



// The root of the subtree is a leaf within the corresponding merkle pollard.
// We calculate this pollardLeafIndex (from the left-most leafIndex of the subtree being added) here.
def calcPollardLeafIndex(field leafIndex) -> (field):
    field TREE_HEIGHT = 128
    field TREE_WIDTH = 340282366920938463463374607431768211456 // = 2 ** TREE_HEIGHT
    field SUBTREE_HEIGHT = 2 // = log_2(# commitments)
    field SUBTREE_DEPTH = 126 // = TREE_HEIGHT - SUBTREE_HEIGHT

    field POLLARD_WIDTH = 85070591730234615865843651857942052864 // = 2 ** SUBTREE_DEPTH (A merkle pollard is an 'upper triangle' of a merkle tree. In this case it's the upper tree with leaves at the level of the root of the subtree).

    // FUTURE ENHANCEMENTS: it would be more efficient if we had an unpackN() for smaller numbers than 128; in this case for N = SUBTREE_HEIGHT
    field[128] leafIndexBits = unpack128(leafIndex)
    field nodeIndex = leafIndexToNodeIndex(leafIndex, TREE_WIDTH)
    field parentNodeIndex = 0

    for field i in 0..SUBTREE_HEIGHT do
      field k = 127 - i // iterator for the leafIndexBits
      parentNodeIndex = if leafIndexBits[k] == 0 then (nodeIndex - 1) else (nodeIndex - 2) fi // ensure divisibility by 2 (in an 'integer sense' rather than field division).
      parentNodeIndex = parentNodeIndex / 2
    endfor

    field parentLeafIndex = nodeIndexToLeafIndex(parentNodeIndex, POLLARD_WIDTH)

    return parentLeafIndex


def calcSubtreeRoot(field[4] leaves) -> (field):
    field SUBTREE_HEIGHT = 2
    field SUBTREE_WIDTH = 4 // 2 ** SUBTREE_HEIGHT
    field SUBTREE_SIZE = 7 // = SUBTREE_WIDTH * 2 - 1
    field UPPER_SUBTREE_SIZE = 3 // = SUBTREE_SIZE - SUBTREE_WIDTH
    field[3] upperSubtree = [0; 3]
    field[7] subtree = [...upperSubtree, ...leaves]

    field node = 0
    for field i in 0..UPPER_SUBTREE_SIZE do
        field j = UPPER_SUBTREE_SIZE - 1 - i
        node = mimc2([subtree[2*j + 1], subtree[2*j + 2]])
        subtree[j] = node
    endfor

    return subtree[0]


// @param {field} latestLeafIndex - the right-most populated leafIndex of the tree BEFORE we add any new leaves. (So the first leaf we add will be at index = latestLeafIndex + 1)
// @param {field} oldRoot - the root currently stored on-chain
// @param {field} newRoot - the new root that will replace the oldRoot
// @param {field[SUBTREE_DEPTH]} siblingPath. The siblingPath for the root of the subtree in the merkle pollard.
def main(\
    field latestLeafIndex,\
    field oldRoot,\
    field newRoot,\
    field[4] newLeaves,\
    private field[126] siblingPath\
) -> ():
    field leftLeafIndex = latestLeafIndex + 1 // the left-most leafIndex of the batch of new leaves we wish to add (although in this circuit we're just adding one leaf).
    field pollardLeafIndex = calcPollardLeafIndex(leftLeafIndex)

    field[8] ROOTS_OF_ZEROS = rootsOfZeros()
    field ROOT_OF_4_ZEROS = ROOTS_OF_ZEROS[2] // = hash(..., hash(0, 0)); the hard-coded root of a subtree of all zeros of height 2.

    // prove that:
    // - the next available subtree was previously empty.
    // - the siblingPath for this pollardLeafIndex is correct, since it resolves to the oldRoot
    oldRoot == calcRoot126(siblingPath, ROOT_OF_4_ZEROS, pollardLeafIndex)

    subtreeRoot = calcSubtreeRoot(newLeaves)

    newRoot == calcRoot126(siblingPath, subtreeRoot, pollardLeafIndex)

    return
