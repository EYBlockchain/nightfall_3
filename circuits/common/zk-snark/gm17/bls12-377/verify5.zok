from "utils/pack_bw6_761/bool/unpack256.zok" import main as field_to_bool_256
from "utils/pack/bool/pack256.zok" import main as bool_256_to_field

from "./structs.zok" import GM17Proof as GM17Proof
import "EMBED/verify5" as verify

struct GM17VerificationKey {
    field[28] vk
}

def generateVKID(GM17VerificationKey vk) -> (field):
    // We compress a VK to be the first coefficient of x-coordinate of the first point of the VK. Collisions are prevented by the smart contract rejecting any other VK submissions with equal vk.H.x[0].
    bool[256] vkIDBits = field_to_bool_256(vk.vk[0]) // convert the little-end (RHS) of the first coefficient of the first coordinate of the vk into 256-bits. (Noting that each coefficient is actually 377-bits, so we're intentionally doing some lossy slicing).
    // We can't use all 256-bits, because we need to refer to the vkID in a 253-bit field. Since we work with hex lots outside of the circuits, we'll use 248-bits of the original value (chosen for divisibility by 8).
    bool[8] padding = [false; 8]
    field vkID = bool_256_to_field([...padding, ...vkIDBits[8..256]])
    return vkID

def main(GM17Proof proof, field[5] publicInputs, GM17VerificationKey vk) -> (bool):
    verify(\
        proof.proof,\
        publicInputs,\
        vk.vk\
    ) == true

    return true
