from "utils/pack_bw6_761/bool/unpack256.zok" import main as field_to_bool_256
from "utils/pack/bool/pack256.zok" import main as bool_256_to_field

from "./structs.zok" import GM17Proof as GM17Proof
import "EMBED/verify7" as verify

struct GM17VerificationKey {
    field[32] vk
}

def generateVKID(GM17VerificationKey vk) -> (field):
    // We compress a VK to be the first coefficient of x-coordinate of the first point of the VK. Collisions are prevented by the smart contract rejecting any other VK submissions with equal vk.H.x[0].
    bool[256] vkIDBits = field_to_bool_256(vk.vk[0]) // convert the little-end (RHS) of the first coefficient of the first coordinate of the vk into 256-bits. (Noting that each coefficient is actually 377-bits, so we're intentionally doing some lossy slicing).
    // We can't use all 256-bits, because we need to refer to the vkID in a 253-bit field. Since we work with hex lots outside of the circuits, we'll use 248-bits of the original value (chosen for divisibility by 8).
    bool[8] padding = [false; 8]
    field vkID = bool_256_to_field([...padding, ...vkIDBits[8..256]])
    return vkID

// A stub that constrains all of the parameters, for testing. Can be deleted once verify7 is added.
def verify7Stub(GM17Proof proof, field[7] publicInputs, GM17VerificationKey vk) -> (bool):
    field[8] p = proof.proof
    field[32] v = vk.vk
    field r = 0
    for field i in 0..8 do
        r = r * p[i]
    endfor
    for field i in 0..7 do
        r = r * publicInputs[i]
    endfor
    for field i in 0..32 do
        r = r * v[i]
    endfor
    return (r * 0 == 0)

def main(GM17Proof proof, field[7] publicInputs, GM17VerificationKey vk) -> (bool):
    verify(\
        proof.proof,\
        publicInputs,\
        vk.vk\
    ) == true

    // verify7Stub(proof, publicInputs, vk) == true

    return true
